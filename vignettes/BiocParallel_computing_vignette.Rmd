---
title: "Genome-wide methylation analysis using coMethDMR via parallel computing"
author: "Gabriel J. Odom, Lissette Gomez, and Lily Wang"
date: "8/1/2019"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 2
    number_sections: true
  word_document:
    toc: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction
In the previous vignette “Introduction to **coMethDMR**”, we discussed components of the **coMethDMR** pipeline and presented example R scripts for running an analysis with **coMethDMR** serially. However, because identifying co-methylated clusters and fitting mixed effects models on large numbers of genomic regions can be computationally expensive, we illustrate implementation of parallel computing via the **BiocParallel** R package in this vignette. 


First, we load these two packages.
```{r packLoad, message=FALSE}
library(coMethDMR)
library(BiocParallel)
```

In Section 2, we give a brief re-introduction to the example data. In Section 3, we present example scripts for analyzing all genomic regions of a single type (e.g. CpG islands) using parallel computing. In Section 4, we present example scripts for analyzing genomic regions from all eleven types on the Illumina arrays (TSS1500, TSS200, UTR5, EXON1, GENEBODY, UTR3, NSHORE, NSHELF, ISLAND, SSHORE and SSHELF) using parallel computing. 



# Example Dataset
For illustration, we use a subset of prefrontal cortex methylation data (GEO GSE59685) described in Lunnon et al. (2014). This example dataset includes beta values for 8552 CpGs on chromosome 22 for a random selection of 20 subjects. We assume quality control and normalization of the methylation dataset have been performed by R packages such as **minfi** or **RnBeads**.
```{r ex_data}
data(betaMatrixChr22_df)
betaMatrixChr22_df[1:5, 1:5]
```

The corresponding phenotype dataset included variables `stage` (Braak AD stage), `subject.id`, `Mplate` (batch effect), `sex`, `Sample` and `age.brain` (age of the brain donor). 
```{r ex_pheno_data}
data(pheno_df)
head(pheno_df)
```

Note that only samples with both methylation data and non-missing phenotype data are analyzed by **coMethDMR**. 


# Analyzing One Type of Genomic Region via BiocParallel
As mentioned previously in “Introduction to **coMethDMR**”, there are several steps in the **coMethDMR** pipeline:

1. Obtain CpGs located closely in pre-defined genomic regions (e.g. CpG islands),
2. Identify co-methylated regions, and
3. Test co-methylated regions against the outcome variable (AD stage).

Suppose we are interested in analyzing CpG islands. In the following, `closeByCGI_ls` is a list, where each item includes CpGs from the Exon 1 regions. 

```{r list_of_cgis}
closeByCGI_ls <- readRDS(
  system.file(
    "extdata",
    "ISLAND3_200.rds",
    package = 'coMethDMR',
    mustWork = TRUE
  )
)

closeByCGI_ls[1]
```

If you are interested in analyzing other types of genomic regions, see “Introduction to **coMethDMR**”, Section 2.1 for necessary modifications to this code. 


## Finding co-methylated regions
The cluster computing with the **BiocParallel** package involves two steps: 

1. Setting up the clusters, and 
2. Passing in the cluster as an argument to `CoMethAllRegions()`. 

First, we set up the cluster: 
```{r create_cluster}
snow_cl <- SnowParam(workers = 8, type = "SOCK")
```

Now we execute the `CoMethAllRegions()` function using each worker in the cluster (this takes about 3 minutes over 8 cores with 16Gb of RAM).

```{r BiocParallel_Exon1, message=FALSE}
# a0 <- Sys.time()
pfcCGIs_ls <- CoMethAllRegions(
  betaMatrix = betaMatrixChr22_df,
  method = "pearson",
  arrayType = "450k",
  regionType = "ISLAND",
  cluster = snow_cl
)
# Sys.time() - a0
```
The object `pfcCGIs_ls` is a list, with each item containing the list of CpGs within an identified co-methylated region. 

Note that to analyze CpG islands, we can pass `closeByCGI_ls` to the `CoMethAllRegions` function, or call for the region type `"ISLAND"` in the co-methylation function below.


## Testing the co-methylated regions
Next we test these co-methylated regions against continuous phenotype stage, adjusting for covariates age and sex.

We now execute the `lmmTestAllRegions()` function in parallel (this takes about 30 seconds over 8 cores with 16Gb of RAM; however, computing the linear mixed model can often take more memory than clustering the co-methylated CpGs):
```{r BiocParallel_lmmTest, warning=FALSE, message=FALSE}
# a1 <- Sys.time()
res_cgi1_df <- lmmTestAllRegions(
  beta_df = betaMatrixChr22_df,
  region_ls = pfcCGIs_ls[1:5],
  pheno_df = pheno_df,
  contPheno_char = "stage",
  covariates_char = c("age.brain", "sex"),
  modelType = "randCoef",
  arrayType = "450k",
  outLogFile = "test.txt", 
  cluster = snow_cl
)
# Sys.time() - a1
```

For a single region, this will return a one row of model fit statistics as shown:

| chrom |    start |      end | nCpGs | Estimate | StdErr |    Stat | pValue |
|-------|----------|----------|-------|----------|--------|---------|--------|
| chr22 | 18268062 | 18268249 |     3 |  -0.0732 | 0.0394 | -1.8564 | 0.0634 |



# Analyzing All Types of Genomic Regions via BiocParallel
Genomic regions on the Illumina arrays can be defined based on their relations to genes or CpG Islands. Genomic regions related to genes include TSS1500, TSS200, UTR5, EXON1, GENEBODY and UTR3. Genomic regions related to CGIs are NSHORE, NSHELF, ISLAND, SSHORE and SSHELF. In this section, we describe analyzing three of these 11 types of genomic regions using coMethDMR. 

Same as before, first, we create the clusters of workers. If you still have the clusters defined, you can reuse them; if not, create them again.
```{r cluster_2, eval=FALSE}
snow_cl <- SnowParam(workers = 8, type = "SOCK")
```

## Analyzing multiple region types
For illustration, we will only analyze CpG islands and shores. If you would like to analyse all region types, use the `AllRegions_char` vector instead of `regions_char`.

```{r setup_for_loop}
# Create vector of region types
# AllRegions_char <- c(
#   "NSHORE", "NSHELF", "SSHORE", "SSHELF", "TSS1500", "TSS200", "UTR5", "EXON1",
#   "GENEBODY", "UTR3", "ISLAND"
# )
regions_char <- c(
  "NSHORE", "SSHORE", "ISLAND"
)

# Create empty results list for region types
resultsAll_ls <- vector(mode = "list", length = length(regions_char))
names(resultsAll_ls) <- regions_char
```

Finally, we execute the wrapper function over each worker on the cluster (this completes in roughly 17 minutes using 8 cores and 24Gb of RAM):
```{r loop_over_region_types, message=FALSE, eval=FALSE}
# aAll <- Sys.time()
for (region in regions_char) {

  print(region) # Uncomment for progress updates
  pfcCGIs_ls <- CoMethAllRegions(
    betaMatrix = betaMatrixChr22_df,
    method = "pearson",
    arrayType = "450k",
    regionType = region,
    cluster = snow_cl
  )
  
  res_df <- lmmTestAllRegions(
    beta_df = betaMatrixChr22_df,
    region_ls = pfcCGIs_ls,
    pheno_df = pheno_df,
    contPheno_char = "stage",
    covariates_char = c("age.brain", "sex"),
    modelType = "randCoef",
    arrayType = "450k",
    cluster = snow_cl
  )
  
  res_df$regionType <- region
  
  resultsAll_ls[[region]] <- res_df
 
}
# Sys.time() - aAll
```

```{r load_results, echo=FALSE}
resultsAll_ls <- readRDS("BiocParallel_AllRegions_Out.RDS")
```

Now that we have the results, we need to stack the model fits for each region.
```{r extract_results_2, warning=FALSE}
lmmResults_df <- do.call(rbind, resultsAll_ls)
row.names(lmmResults_df) <- NULL

head(lmmResults_df)
```
We can see this output is similar to the previous output, with the additional column identifying the region type of each region.

## Annotate results
Finally, we may be interested in the specific probes in these regions, or which genes overlap with these regions. We can thus use the `AnnotateResults()` function, which takes in the results data frame above (or a data frame of the results returned by `lmmTest()` or `lmmTestAllRegions()`).
```{r annotate_results}
lmmResAnnotated_df <- AnnotateResults(
  lmmRes_df = lmmResults_df,
  arrayType = "450k"
)
head(lmmResAnnotated_df)
```

We can save our results by:
```{r save_results, eval=FALSE}
write.csv(
  lmmResAnnotated_df,
  file = "EWAS_PFC_lmmOut.csv"
)
```



# Additional Comments on Computational Time and Resources
In this vignette, we have analyzed a small subset of a real EWAS dataset (i.e. only chromosome 22 data on 20 subjects). To give users a more realistic estimate of time for analyzing real EWAS datasets, we also measured time used for analyzing the entire Lunnon et al. (2014) dataset with 110 samples on all chromosomes. These computation times measured on a Dell Precision 5810 with 64Gb of RAM, an Intel Xeon E5-2640 CPU at 2.40Ghz, and using up to 20 cores. More specifically, in Section 4, the entire **coMethDMR** workflow for all 11 types of genomic regions took 50 minutes with 12 cores and used 24Gb of RAM. We’re currently working improving the speed and reducing the size of **coMethDMR**, so please check back soon for updates.  
