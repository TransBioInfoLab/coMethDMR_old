---
title: "Genome-wide methylation analysis using coMethDMR via parallel computing"
author: "Gabriel J. Odom, Lissette Gomez, and Lily Wang"
date: "7/22/2019"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 2
    number_sections: true
  word_document:
    toc: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction
In the previous vignette “Introduction to **coMethDMR**”, we discussed components of the **coMethDMR** pipeline and presented example R scripts for running an analysis with **coMethDMR** serially. However, because identifying co-methylated clusters and fitting mixed effects models on large numbers of genomic regions can be computationally expensive, we illustrate implementation of parallel computing via the **BiocParallel** R package in this vignette. 


First, we load these two packages.
```{r packLoad, message=FALSE}
library(coMethDMR)
library(BiocParallel)
```

In Section 2, we give a brief re-introduction to the example data. In Section 3, we present example scripts for analyzing all genomic regions of a single type (e.g. CpG islands) using parallel computing. In Section 4, we present example scripts for analyzing genomic regions from all eleven types on the Illumina arrays (TSS1500, TSS200, UTR5, EXON1, GENEBODY, UTR3, NSHORE, NSHELF, ISLAND, SSHORE and SSHELF) using parallel computing. 



# Example Dataset
For illustration, we use a subset of prefrontal cortex methylation data (GEO GSE59685) described in Lunnon et al. (2014). This example dataset includes beta values for 8552 CpGs on chromosome 22 for a random selection of 20 subjects. We assume quality control and normalization of the methylation dataset have been performed by R packages such as **minfi** or **RnBeads**.
```{r ex_data}
data(betaMatrixChr22_df)
betaMatrixChr22_df[1:5, 1:5]
```

The corresponding phenotype dataset included variables `stage` (Braak AD stage), `subject.id`, `Mplate` (batch effect), `sex`, `Sample` and `age.brain` (age of the brain donor). 
```{r ex_pheno_data}
data(pheno_df)
head(pheno_df)
```

Note that only samples with both methylation data and non-missing phenotype data are analyzed by **coMethDMR**. 


# Analyzing One Type of Genomic Region via BiocParallel
As mentioned previously in “Introduction to **coMethDMR**”, there are several steps in the **coMethDMR** pipeline:

1. Obtain CpGs located closely in pre-defined genomic regions (e.g. CpG islands),
2. Identify co-methylated regions, and
3. Test co-methylated regions against the outcome variable (AD stage).

Suppose we are interested in analyzing CpG islands. In the following, `closeByCGI_ls` is a list, where each item includes CpGs from the Exon 1 regions. 

```{r list_of_cgis}
closeByCGI_ls <- readRDS(
  system.file(
    "extdata",
    "EXON13_200.rds",
    package = 'coMethDMR',
    mustWork = TRUE
  )
)

closeByCGI_ls[1]
```

If you are interested in analyzing other types of genomic regions, see “Introduction to **coMethDMR**”, Section 2.1 for necessary modifications to this code. 


## Finding co-methylated regions
The cluster computing with the **BiocParallel** package involves several steps: 

1. Setting up the clusters,
2. Creating a wrapper function to load the packages and call functions, and 
3. Executing the wrapper function on each worker in the computing cluster. 

First, we set up the cluster: 
```{r create_cluster}
snow_cl <- SnowParam(workers = 12, type = "SOCK")
```

Next, we create a wrapper function: 
```{r create_coMeth_worker_1}
coMeth_worker <- function(x, beta_mat){

  suppressPackageStartupMessages({
    library(coMethDMR)
 })

  CoMethSingleRegion(
    CpGs_char = x,
    betaMatrix = beta_mat,
    method = "pearson",
    arrayType = "450k",
    returnAllCpGs = FALSE
  )

}
```

Finally, we execute the wrapper function `coMeth_worker()` over each worker in the cluster (this takes about 3 minutes over 12 cores with 50Gb of RAM).
```{r BiocParallel_Islands, message=FALSE}
a0 <- Sys.time()
coMethIslandCpGs_ls <- bplapply(
  # The list of regions to apply over
  X = closeByCGI_ls,
  # The worker function that calls CoMethSingleRegion()
  FUN = coMeth_worker,
  # Specify the cluster of workers
  BPPARAM = snow_cl,
  # beta values passed through the worker function to CoMethSingleRegion()
  beta_mat = betaMatrixChr22_df 
)
Sys.time() - a0
```

Because these results are in a nested list, we need to extract the results.
```{r extract_results_1}
pfc_cgi_ls <- unlist(
  lapply(coMethIslandCpGs_ls, `[[`, 2),
  recursive = FALSE
)
```
The object `pfc_cgi_ls` is a list, with each item containing the list of CpGs within an identified co-methylated region. 


## Testing the co-methylated regions
Next we test these co-methylated regions against continuous phenotype stage, adjusting for covariates age and sex.

As before, we first create a worker function. This function have three arguments: the vector of CpG locations in a co-methylated cluster, the data frame of methylation values, and the data frame of response and covariates.
```{r lmmTest_worker_1}
TestRegions_worker <- function(cgi, beta_mat, pheno_mat){

  suppressPackageStartupMessages({
    library(coMethDMR)
  })

  coMethBetaDF <- beta_mat[which(rownames(beta_mat) %in% cgi), ]

  lmmTest(
    betaOne_df = coMethBetaDF,
    pheno_df = pheno_mat,
    contPheno_char = "stage",
    covariates_char = c("age.brain", "sex"),
    modelType = "randCoef",
    arrayType = "450k"
  )

}

```

Next, we execute this function in parallel (this takes 1.7 minutes over 12 cores with 52Gb of RAM; computing the linear mixed model takes more memory than clustering the co-methylated CpGs):
```{r BiocParallel_lmmTest, warning=FALSE, message=FALSE}
a1 <- Sys.time()
results_ls <- bplapply(
  X = pfc_cgi_ls,
  FUN = TestRegions_worker,
  BPPARAM = snow_cl,
  beta_mat = betaMatrixChr22_df,
  pheno_mat = pheno_df
)

Sys.time() - a1
```

For a single region, this will return a one row of model fit statistics as shown:

| chrom |    start |      end | nCpGs | Estimate | StdErr |    Stat | pValue |
|-------|----------|----------|-------|----------|--------|---------|--------|
| chr22 | 18268062 | 18268249 |     3 |  -0.0732 | 0.0394 | -1.8564 | 0.0634 |

Because `lmmTest()` returns a one-row data frame, we will stack these results into a data frame and add the false discovery rate (FDR):
```{r doCall_rbind_1}
res_cgi1_df <- do.call(rbind, results_ls)
res_cgi1_df$FDR <- p.adjust(res_cgi1_df$pValue, method = "fdr")
row.names(res_cgi1_df) <- NULL 

res_cgi1_df
```

# Analyzing All Types of Genomic Regions via BiocParallel
Genomic regions on the Illumina arrays can be defined based on their relations to genes or CpG Islands. Genomic regions related to genes include TSS1500, TSS200, UTR5, EXON1, GENEBODY and UTR3. Genomic regions related to CGIs are NSHORE, NSHELF, ISLAND, SSHORE and SSHELF. In this section, we describe analyzing three of these 11 types of genomic regions using coMethDMR. 

Same as before, first, we create the clusters of workers. If you still have the clusters defined, you can reuse them; if not, create them again.
```{r cluster_2, eval=FALSE}
snow_cl <- SnowParam(workers = 12, type = "SOCK")
```

## Create the worker function
Next, we create the wrapper function for the entire workflow, here we wrap around both the co-methlyated clustering function and the linear mixed model function. If you plan to modify this function, we recommend that you test it extensively on one of the smaller region types, such as the South Shelf.
```{r whole_pipeline_worker}
coMethDMR_worker <- function(cpgs, beta_mat, pheno_mat, regionType_char){

  suppressPackageStartupMessages({
    library(coMethDMR)
  })

  cgi_ls <- CoMethSingleRegion(
    CpGs_char = cpgs,
    betaMatrix = beta_mat,
    method = "pearson",
    arrayType = "450k",
    returnAllCpGs = FALSE
  )
  
  if(is.null(cgi_ls)){
    return(NULL)
  } else if(is.null(cgi_ls$CpGsSubregions)){
    return(NULL)
  } else {
    
    # This second element could be a list itself
    subregions_ls <- cgi_ls[[2]]
    mods_ls <- lapply(subregions_ls, function(cgi){

      coMethBetaDF <- beta_mat[which(rownames(beta_mat) %in% cgi), ]

      lmmTest(
        betaOne_df = coMethBetaDF,
        pheno_df = pheno_mat,
        contPheno_char = "stage",
        covariates_char = c("age.brain", "sex"),
        modelType = "randCoef",
        arrayType = "450k"
      )

    })

    cgi_ls$modelFits_df <- do.call(rbind, mods_ls)
    cgi_ls$modelFits_df$regionType <- regionType_char
    cgi_ls
    
  }

}
```

## Analyzing multiple region types
For illustration, we will only analyze CpG islands and shores. If you would like to analyse all region types, use the `AllRegions_char` vector instead of `regions_char`.

```{r setup_for_loop}
# Create vector of region types
# AllRegions_char <- c(
#   "NSHORE", "NSHELF", "SSHORE", "SSHELF", "TSS1500", "TSS200", "UTR5", "EXON1",
#   "GENEBODY", "UTR3", "ISLAND"
# )
regions_char <- c(
  "NSHORE", "SSHORE", "ISLAND"
)

# Create empty results list for region types
resultsAll_ls <- vector(mode = "list", length = length(regions_char))
names(resultsAll_ls) <- regions_char
```

Finally, we execute the wrapper function over each worker on the cluster (this completes in roughly 15 minutes using 12 cores and 52Gb of RAM):
```{r loop_over_region_types, eval=FALSE}
aAll <- Sys.time()
for (region in regions_char) {

  # print(region) # Uncomment for progress updates

  closeByGenomicRegion_ls <- readRDS(
    system.file(
      "extdata",
      paste0(region, "3_200.rds"),
      package = 'coMethDMR',
      mustWork = TRUE
    )
  )
  closeByGenomicRegion_ls <- unname(closeByGenomicRegion_ls)

  res_ls <- bplapply(
    X = closeByGenomicRegion_ls,
    FUN = coMethDMR_worker,
    BPPARAM = snow_cl,
    beta_mat = betaMatrixChr22_df,
    pheno_mat = pheno_df,
    regionType_char = region
  )
  resultsAll_ls[[region]] <- res_ls[lengths(res_ls) > 0]
 
}
Sys.time() - aAll
```
```{r load_results, echo=FALSE}
resultsAll_ls <- readRDS("BiocParallel_AllRegions_Out.RDS")
```

Now that we have the results, we need to extract the model fits for each region.
```{r extract_results_2, warning=FALSE}
lmmResults_ls <- lapply(resultsAll_ls, function(regionType){

  out_ls <- lapply(regionType, `[[`, "modelFits_df")
  do.call(rbind, out_ls)

})

lmmResults_df <- do.call(rbind, lmmResults_ls)
row.names(lmmResults_df) <- NULL

head(lmmResults_df)
```
We can see this output is similar to the previous output, with the additional column identifying the region type of each region.

## Annotate results
Finally, we may be interested in the specific probes in these regions, or which genes overlap with these regions. We can thus use the `AnnotateResults()` function, which takes in the results data frame above (or a data frame of the results returned by `lmmTest()` or `lmmTestAllRegions()`).
```{r annotate_results}
lmmResAnnotated_df <- AnnotateResults(
  lmmRes_df = lmmResults_df,
  arrayType = "450k"
)
head(lmmResAnnotated_df)
```

We can save our results by:
```{r save_results, eval=FALSE}
write.csv(
  lmmResAnnotated_df,
  file = "EWAS_PFC_lmmOut.csv"
)
```



# Additional Comments on Required Computing Resources
In this vignette, we have analyzed a small subset of a real EWAS dataset (i.e. only chromosome 22 data on 20 subjects). To give users a more realistic estimate of time for analyzing real EWAS datasets, we also measured time used for analyzing the entire Lunnon et al. (2014) dataset with 110 samples on all chromosomes. These computation times measured on a Dell Precision 5810 with 64Gb of RAM, an Intel Xeon E5-2640 CPU at 2.40Ghz, and using up to 20 cores. 

More specifically, in Section 4, the entire coMethDMR for all 11 types of genomic regions took 97 minutes with 12 cores. In section 3.1, finding the comethylated clusters of CpGs in CpG islands took 12 minutes with 12 cores. In Section 3.2, fitting linear mixed models to co-methylated CpG clusters took 3.7 minutes with 12 cores. 
We’re currently working improving the speed and reducing the size of coMethDMR, so please check back soon for updates.  
