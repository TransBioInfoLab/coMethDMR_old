---
title: "Genome-wide methylation analysis using coMethDMR via parallel computing"
author: "Gabriel J. Odom, Lissette Gomez, and Lily Wang"
date: "8/20/2019"
output:
  html_document:
    number_sections: yes
    toc: yes
    toc_depth: 2
    toc_float: false
  pdf_document:
    toc: yes
    toc_depth: '2'
  word_document:
    toc: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction
In the previous vignette “Introduction to **coMethDMR**”, we discussed components of the **coMethDMR** pipeline and presented example R scripts for running an analysis with **coMethDMR** serially. However, because identifying co-methylated clusters and fitting mixed effects models on large numbers of genomic regions can be computationally expensive, we illustrate implementation of parallel computing for **coMethDMR** via the **BiocParallel** R package in this vignette. 


First, we load these two packages.
```{r packLoad, message=FALSE}
library(coMethDMR)
library(BiocParallel)
```

In Section 2, we give a brief re-introduction to the example data. In Section 3, we present example scripts for analyzing a single type (e.g. CpG islands) of genomic regions using parallel computing. In Section 4, we present example scripts for analyzing genomic regions from all eleven types on the Illumina arrays (TSS1500, TSS200, UTR5, EXON1, GENEBODY, UTR3, NSHORE, NSHELF, ISLAND, SSHORE and SSHELF) using parallel computing. 

# Example Dataset
For illustration, we use a subset of prefrontal cortex methylation data (GEO GSE59685) described in Lunnon et al. (2014). This example dataset includes beta values for 8552 CpGs on chromosome 22 for a random selection of 20 subjects. We assume quality control and normalization of the methylation dataset have been performed by R packages such as **minfi** or **RnBeads**.
```{r ex_data}
data(betaMatrixChr22_df)
betaMatrixChr22_df[1:5, 1:5]
```

The corresponding phenotype dataset included variables `stage` (Braak AD stage), `subject.id`, `Mplate` (batch effect), `sex`, `Sample` and `age.brain` (age of the brain donor). 
```{r ex_pheno_data}
data(pheno_df)
head(pheno_df)
```

Note that only samples with both methylation data and non-missing phenotype data are analyzed by **coMethDMR**. So in this example, the sample with `subject.id = 3` which lacks AD stage information will be excluded from analysis. 


# Analyzing One Type of Genomic Region via BiocParallel
As mentioned previously in “Introduction to **coMethDMR**”, there are several steps in the **coMethDMR** pipeline:

1. Obtain CpGs located closely in pre-defined genomic regions (e.g. CpG islands),
2. Identify co-methylated regions, and
3. Test co-methylated regions against the outcome variable (AD stage).

Suppose we are interested in analyzing genomic regions corresponding to the gene promoter regions, specifically the `TSS200` regions. In the following, `closeByTSS200_ls` is a list, where each item includes CpGs located closely (max distance between 2 CpGs is 200bp by default) in the `TSS200` regions. 

```{r list_of_cgis}
closeByTSS200_ls <- readRDS(
  system.file(
    "extdata",
    "TSS200_3_200.rds",
    package = 'coMethDMR',
    mustWork = TRUE
  )
)

closeByTSS200_ls[1]
```

If you are interested in analyzing other types of genomic regions, see “Introduction to **coMethDMR**”, Section 2.1 for necessary modifications to this code. 


## Finding co-methylated regions
The cluster computing with the **BiocParallel** package involves two steps: 

1. Setting up the clusters, and 
2. Passing in the cluster as an argument to `CoMethAllRegions()`. 

First, we set up the cluster: 
```{r create_cluster}
snow_cl <- SnowParam(workers = 20, type = "SOCK")
```

Now we execute the `CoMethAllRegions()` function using each worker in the cluster, to find co-methylated clusters in the TSS200 regions. 

Note that for demonstration, the following script evaluates only the first 500 regions by setting `CpGs_ls = closeByTSS200_ls[1:500]`, to identify co-methylated clusters in all 10907 TSS200 regions, change to `CpGs_ls = closeByTSS200_ls`. This would take about 6 minutes over 20 cores with 64Gb of RAM.    

```{r BiocParallel_TSS200, message=FALSE}
a0 <- Sys.time()
coMeth_ls <- CoMethAllRegions(
  dnam = betaMatrixChr22_df,
  method = "spearman",
  arrayType = "450k",
  CpGs_ls = closeByTSS200_ls[1:500],
  cluster = snow_cl
)
Sys.time() - a0
```

Note that argument `regionType = "TSS200"` can also be used to obtain the co-methyalted regions. The following scripts are equivalent to the block of scripts above. 


```{r BiocParallel_TSS200_1, message=FALSE, eval=FALSE}
a0 <- Sys.time()
coMeth_ls <- CoMethAllRegions(
  dnam = betaMatrixChr22_df,
  method = "spearman",
  arrayType = "450k",
  regionType = "TSS200",
  cluster = snow_cl
)
Sys.time() - a0
```
The object `coMeth_ls` is a list, with each item containing the list of CpGs within an identified co-methylated region. 


## Testing the co-methylated regions
Next we test these co-methylated regions against continuous phenotype stage, adjusting for covariates age and sex. We now execute the `lmmTestAllRegions()` function. This completes in a few seconds for the TSS200 regions. Note that computing the linear mixed model can often take more memory than identifying co-methylated regions.

```{r singleRegionType_lmmTest, warning=FALSE, results='hide'}
res_df <- lmmTestAllRegions(
  betas = betaMatrixChr22_df,
  region_ls = coMeth_ls,
  pheno_df = pheno_df,
  contPheno_char = "stage",
  covariates_char = c("age.brain", "sex"),
  modelType = "randCoef",
  arrayType = "450k",
  outLogFile = "res_lmm_log.txt"
)
```

Model fit messages and diagnostics for each region will be saved to the log file specified with the `outLogFile` argument. For a single region, this will return a one row of model fit statistics similar to the following:

| chrom |    start |      end | nCpGs | Estimate | StdErr |    Stat | pValue |
|-------|----------|----------|-------|----------|--------|---------|--------|
| chr22 | 24823455 | 24823519 |      4|  -0.0702 | 0.0290 | -2.4184 | 0.0155 |

<!-- Because the linear mixed model may fail to converge in some cases, we want to record the computational logs from the parallel workers. To do this, we add additional information to the clusters. -->
<!-- ```{r add_BP_log, eval=FALSE} -->
<!-- snow_cl <- SnowParam(workers = 8, type = "SOCK") -->
<!-- register(snow_cl) -->

<!-- bplog(snow_cl) <- TRUE -->

<!-- dirName <- paste0("lmm_results_log_", Sys.Date(), "/") -->
<!-- dir.create(dirName) -->
<!-- bplogdir(snow_cl) <- dirName -->
<!-- ``` -->



# Analyzing All Types of Genomic Regions via BiocParallel
Genomic regions on the Illumina arrays can be defined based on their relations to genes or CpG Islands. Genomic regions annotated to genes include TSS1500, TSS200, UTR5, EXON1, GENEBODY and UTR3. Genomic regions annotated to CGIs are NSHORE, NSHELF, ISLAND, SSHORE and SSHELF. In this section, we describe analyzing three of these 11 types of genomic regions using coMethDMR. 

Same as before, first, we create the clusters of workers. If you still have the clusters defined, you can reuse them; if not, create them again.
```{r cluster_2, eval=FALSE}
snow_cl <- SnowParam(workers = 20, type = "SOCK")
```

## Analyzing multiple region types
For illustration, we will only analyze CpG islands and shores. If you would like to analyse all region types, use the `AllRegions_char` vector instead of `regions_char`.

```{r setup_for_loop}
# Create vector of region types
# AllRegions_char <- c(
#   "NSHORE", "NSHELF", "SSHORE", "SSHELF", "TSS1500", "TSS200", "UTR5", "EXON1",
#   "GENEBODY", "UTR3", "ISLAND"
# )
regions_char <- c(
  "NSHORE", "SSHORE", "ISLAND"
)

# Create empty results list for region types
resultsAll_ls <- vector(mode = "list", length = length(regions_char))
names(resultsAll_ls) <- regions_char
```

Finally, we execute the `CoMethAllRegions()` function over each worker on the cluster (this completes in roughly 17 minutes using 20 cores and 64Gb of RAM), then pass these results to `lmmTestAllRegions()`:
```{r loop_over_region_types, eval=FALSE}
aAll <- Sys.time()

for (region in regions_char) {

  print(region) # Uncomment for progress updates
  pfcRegions_ls <- CoMethAllRegions(
    dnam = betaMatrixChr22_df,
    method = "spearman",
    arrayType = "450k",
    regionType = region,
    cluster = snow_cl
  )
  
  res_df <- lmmTestAllRegions(
    betas = betaMatrixChr22_df,
    region_ls = pfcRegions_ls,
    pheno_df = pheno_df,
    contPheno_char = "stage",
    covariates_char = c("age.brain", "sex"),
    modelType = "randCoef",
    arrayType = "450k",
    outLogFile = paste0(region, "_lmm_log.txt")
  )
  
  res_df$regionType <- region
  
  resultsAll_ls[[region]] <- res_df
 
}

Sys.time() - aAll
```

```{r load_results, echo=FALSE}
resultsAll_ls <- readRDS("BiocParallel_shores_islands_Out.RDS")
```

Now that we have the results, we need to stack the model fits for each region.
```{r extract_results_2, warning=FALSE}
lmmResults_df <- do.call(rbind, resultsAll_ls)
row.names(lmmResults_df) <- NULL

head(lmmResults_df)
```
We can see this output is similar to the previous output, with the additional column annotating the type of genomic region corresponding to each co-methylated region.

## Annotate results
Finally, we may be interested in the specific probes in these regions, or which genes overlap with these regions. We can use the `AnnotateResults()` function.
```{r annotate_results}
lmmResAnnotated_df <- AnnotateResults(
  lmmRes_df = lmmResults_df,
  arrayType = "450k"
)
head(lmmResAnnotated_df)
```

Finally. we can save our results:
```{r save_results, eval=FALSE}
write.csv(
  lmmResAnnotated_df,
  file = "EWAS_PFC_lmmOut.csv"
)
```



# Additional Comments on Computational Time and Resources
In this vignette, we have analyzed a small subset of a real EWAS dataset (i.e. only chromosome 22 data on 20 subjects). To give users a more realistic estimate of time for analyzing real EWAS datasets, we also measured time used for analyzing the entire Lunnon et al. (2014) dataset with 110 samples on all chromosomes. These computation times measured on a Dell Precision 5810 with 64Gb of RAM, an Intel Xeon E5-2640 CPU at 2.40Ghz, and using up to 20 cores. More specifically, in Section 4, the entire **coMethDMR** workflow for all 11 types of genomic regions took 50 minutes with 12 cores and used 24Gb of RAM. We’re currently working improving the speed and reducing the size of **coMethDMR**, so please check back soon for updates.  
